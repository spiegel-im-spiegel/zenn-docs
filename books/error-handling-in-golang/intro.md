---
title: "はじめに"
---

プログラミングにおいて，正常系は基本的に「一本道」だが，異常系は（予期しないものも含めて）無数にある。エラーハンドリングは巨大迷路パズルを袋小路から順に塗りつぶして「正解」をあぶり出していく作業に似ていると思う。下手くそな迷路攻略はただの「作業」だが，よく考えられた迷路は袋小路の配置も美しい。

こんなふうに考えるなら，プログラム設計の肝はエラー（＝袋小路）をどう記述するかにかかっている，と言えるだろう。

私が [Go] のエラーハンドリングについて最初に記事にしたのは[2015年](https://text.baldanders.info/golang/error-handling/ "エラー・ハンドリングについて（追記あり）")のことだが，あれから [Go] も少しずつ変わってるし，私も当時よりは多少なりと理解が進んだと思うので，今まで書いた駄文を「全部入り」で本の形にしてみようと思う。

## もはや「例外」は Legacy

私は C/C++ や Java などから来た人間なので [Go] を始めたばかりの頃は「例外（Exception）」のないエラーハンドリングに面食らったものだが，今ではすっかり慣れてしまった。

今年（2020年）になって Rust の勉強を少しだけ始めたが，改めて分かった。


💡 **もはや「例外」は Legacy だ！** 💡

たとえば Rust は[列挙型と match 式を組み合わせてエラーの抽出と評価を行う](https://text.baldanders.info/rust-lang/error-handling/ "エラー・ハンドリングのキホン")ことでエラー・ハンドリングを実装できる。

```rust
fn main() {
    let n = match parse_string("-1") {
        Ok(x) => x,
        Err(e) => panic!(e), //Output: thread 'main' panicked at 'Box<Any>', src/main.rs:8:19
    };
    println!("{}", n); //do not reach
}
```

実にスマート！

## 「例外」の問題は “goto” と同じ[^goto1]

[^goto1]: ちなみに [Go] の `goto` や ラベル付きの `break`, `continue` は[飛び先に制約](https://golang.org/test/goto.go)があり，どこにでもジャンプできるわけではない。

「例外」では，あるオブジェクトに関する記述が少なくとも2つ（たとえば try と catch）下手をすると3つ以上のスコープに分割されてしまう。しかもオブジェクトの状態ごと大域脱出するため，その状態（の可能性）の後始末をスコープ間で漏れなく矛盾なく記述しきらなければならない。

この一連に不備があれば，バグやリークやその他の脆弱性のもとになる。考えるだけで面倒である。



[Go]: https://golang.org/ "The Go Programming Language"
<!-- eof -->
